<!DOCTYPE html>
<html lang="es" data-theme="light">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>K√∂nigsberg ‚Äî Grafo Equivalente (Interactivo)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
:root{
  --bg: #f8fafc;
  --paper: #ffffff;
  --ink: #0f172a;
  --muted: #64748b;
  --border-color: #e2e8f0;
  --bridge: #b45309;
  --bridge-hover: #f59e0b;
  --used: #94a3b8;
  --ok: #16a34a;
  --warn: #f59e0b;
  --accent: #2563eb;
  --success: #059669;
  --shadow: 0 12px 28px rgba(2,6,23,.08);
  --glow: 0 0 20px rgba(22,163,74,.3);
  --dfs-explore: #8b5cf6;
  --dfs-backtrack: #ef4444;
}

[data-theme="dark"] {
  --bg: #0f172a;
  --paper: #1e293b;
  --ink: #f1f5f9;
  --muted: #94a3b8;
  --border-color: #334155;
  --bridge: #f59e0b;
  --bridge-hover: #fbbf24;
  --used: #475569;
  --ok: #22c55e;
  --warn: #f59e0b;
  --accent: #3b82f6;
  --success: #10b981;
  --shadow: 0 12px 28px rgba(0,0,0,.3);
  --glow: 0 0 20px rgba(34,197,94,.4);
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink);transition: background .2s, color .2s;}
header{position:sticky;top:0;background:var(--paper);border-bottom:1px solid var(--border-color);box-shadow:var(--shadow);z-index:10}
.wrap{max-width:1100px;margin:0 auto;padding:14px 18px}
h1{margin:.1rem 0;font-size:clamp(20px,3.2vw,28px)}
.sub{color:var(--muted);font-size:.95rem;line-height:1.5}
.controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
button{border:none;border-radius:10px;padding:9px 13px;font-weight:700;background:var(--paper); color: var(--ink); box-shadow:var(--shadow);cursor:pointer;transition:.18s transform,.18s box-shadow,.18s background, .18s color}
button:hover{transform:translateY(-1px);box-shadow:0 8px 25px rgba(2,6,23,.12)}
.primary{background:var(--accent);color:#fff}
[data-theme="dark"] .primary:hover{background:#2563eb;}
.warn{background:var(--warn);color:#fff}
[data-theme="dark"] .warn:hover{background:#d97706;}
.success{background:var(--success);color:#fff}
[data-theme="dark"] .success:hover{background:#047857;}
.ghost{background:var(--paper);color:var(--ink);border:1px solid var(--border-color)}
.ghost:hover{background:var(--bg);border-color:var(--accent)}
.explore{background:var(--dfs-explore); color:white;}

button:focus-visible, .node:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

.main{max-width:1100px;margin:14px auto;padding:0 18px}
.panel{background:var(--paper);border:1px solid var(--border-color);border-radius:14px;padding:12px 14px;box-shadow:var(--shadow);margin-bottom:14px}
.stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px}
.stat{background:var(--bg);border:1px solid var(--border-color);border-radius:10px;padding:8px 10px;transition:.2s transform}
.stat:hover{transform:translateY(-1px)}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace;background:var(--paper);border:1px solid var(--border-color);border-radius:6px;padding:1px 6px}
.explanation{background:linear-gradient(135deg, var(--bg), var(--paper));border-left:4px solid var(--accent);padding:12px;border-radius:8px;margin:12px 0;font-size:.9rem;line-height:1.6}

.board{position:relative;background:var(--paper);border:1px solid var(--border-color);border-radius:18px;box-shadow:var(--shadow);overflow:hidden}
svg{display:block;width:100%;height:auto;background:linear-gradient(135deg, #eef2ff, #e2e8f0)}
[data-theme="dark"] svg{background:linear-gradient(135deg, var(--bg), #1e293b);}

/* Grafo */
.edge{fill:none;stroke:var(--muted);stroke-width:2.6;cursor:pointer;transition:.18s stroke,.18s opacity,.18s stroke-width}
.edge:hover{stroke:var(--bridge-hover);stroke-width:3.2;filter:drop-shadow(0 0 8px rgba(245,158,11,.4))}
.edge.available{stroke:var(--ok);stroke-width:3.2;filter:var(--glow);animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.8}}
.edge.used{stroke:var(--used);opacity:.7;cursor:not-allowed}
.edge.dfs-explore { stroke: var(--dfs-explore); stroke-width: 3.5px; }
.edge.dfs-backtrack { stroke: var(--dfs-backtrack); opacity: 0.8; stroke-dasharray: 4 4; animation: dash 1s linear infinite;}
@keyframes dash { to { stroke-dashoffset: -20; }}

.node{fill:#ef4444;stroke:var(--paper);stroke-width:3;cursor:pointer;transition:.2s transform,.2s filter, .2s fill}
.node:hover{transform:scale(1.1);filter:drop-shadow(0 0 8px rgba(239,68,68,.4))}
.node.active{fill:var(--ok);filter:drop-shadow(0 0 12px var(--glow))}
.node.heat-1 { fill: #fde047; }
.node.heat-2 { fill: #f59e0b; }
.node.heat-3 { fill: #ea580c; }
.node.heat-4 { fill: #dc2626; }
.node.heat-5 { fill: #b91c1c; filter: drop-shadow(0 0 12px #ef4444) }

.label{font:700 14px/1 Inter,system-ui,sans-serif; fill:var(--ink);-webkit-user-select:none;user-select:none}
.big{font:800 16px/1 Inter,system-ui,sans-serif}
#walker-graph{fill:var(--ink); stroke:var(--paper); stroke-width:2;filter:drop-shadow(0 0 6px rgba(17,24,39,.6))}

/* Modals & Overlays */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:100}
.modal-content{background:var(--paper);border:1px solid var(--border-color);border-radius:16px;padding:24px;max-width:600px;max-height:80vh;overflow-y:auto;box-shadow:var(--shadow)}
.paths-modal, .dfs-modal{max-width:95vw; max-height:90vh; width: 1400px;}
.paths-info{margin-bottom:16px;padding:12px;background:var(--bg);border-radius:8px;border-left:4px solid var(--accent)}
.paths-container{max-height:400px;overflow-y:auto;border:1px solid var(--border-color);border-radius:8px;background:var(--paper)}
.path-item{background:var(--bg);border:1px solid var(--border-color);border-radius:8px;padding:10px;cursor:pointer;transition:.2s transform,.2s background}
.path-item:hover{background:var(--paper);transform:translateY(-1px)}
.path-item.selected{background:var(--accent);color:#fff;border-color:var(--accent)}
.path-item.selected .path-number{color:#fff}
[data-theme="dark"] .path-item.selected{color:#fff;}
.path-item .path-number{font-weight:700;color:var(--accent);margin-bottom:4px}
.path-item .path-sequence{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.9rem;word-break:break-all}
.paths-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:16px;flex-wrap:wrap}

/* DFS Explorer Modal */
.dfs-explorer-layout { display: flex; flex-direction: column; height: 75vh; }
.dfs-explorer-content { display: grid; grid-template-columns: 1fr 400px; gap: 16px; flex-grow: 1; min-height: 0; }
.dfs-main-panel { display: flex; flex-direction: column; min-height: 0; }
.dfs-side-panel { display: grid; grid-template-rows: auto 1fr; gap: 12px; font-size: 0.9rem; min-height: 0;}
.dfs-panel { background: var(--bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; display: flex; flex-direction: column;}
.dfs-panel h4 { margin: 0 0 8px; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; color: var(--accent); }
.dfs-log-container { flex-grow: 1; overflow-y: auto; font-family: ui-monospace, mono; font-size: 0.85rem; }
.dfs-log-entry { padding: 4px; border-radius: 4px; margin-bottom: 2px; }
.dfs-log-entry.push { color: var(--dfs-explore); }
.dfs-log-entry.pop { color: var(--dfs-backtrack); background-color: rgba(239, 68, 68, 0.1); }
.dfs-log-entry.solution { color: var(--success); font-weight: bold; }
.dfs-stack { display: flex; flex-wrap: wrap; gap: 4px; }
.dfs-stack-item { background: var(--paper); border: 1px solid var(--border-color); padding: 4px 8px; border-radius: 6px; font-weight: bold; }
.dfs-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.dfs-timeline { background: var(--bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 8px; margin-top: 16px; display: flex; gap: 2px; overflow-x: auto; white-space: nowrap; }
.timeline-item { display: inline-block; padding: 4px 8px; border-radius: 4px; font-family: ui-monospace, mono; font-size: 0.8rem; }
.timeline-item.push { background-color: var(--dfs-explore); color: white; }
.timeline-item.pop { background-color: var(--dfs-backtrack); color: white; }
.timeline-item.solution { background-color: var(--success); color: white; }
#dfs-tree-container { flex-grow: 1; min-height: 300px; }
#dfs-tree-svg { display: block; width: 100%; height: 100%; }
.tree-link { stroke: var(--muted); stroke-width: 1.5; transition: stroke .2s; }
.tree-link.active { stroke: var(--dfs-explore); stroke-width: 2.5; }
.tree-link.solution { stroke: var(--success); stroke-width: 2.5; }
.tree-link.dead-end { stroke: var(--dfs-backtrack); }
.tree-node { fill: var(--paper); stroke: var(--muted); stroke-width: 1; transition: r .2s, fill .2s, stroke .2s; }
.tree-node.active { fill: var(--dfs-explore); stroke: var(--dfs-explore); }
.tree-node.solution { fill: var(--success); stroke: var(--paper); }
.tree-node.dead-end { fill: var(--dfs-backtrack); stroke: var(--dfs-backtrack); }
.tree-label { font-size: 10px; font-family: Inter, sans-serif; fill: var(--ink); text-anchor: middle; pointer-events: none; }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>üåâ Los 7 Puentes de K√∂nigsberg ‚Äî Grafo Equivalente</h1>
    <div class="sub">
      <strong>Problema hist√≥rico:</strong> ¬øEs posible cruzar cada puente exactamente una vez y regresar al punto de partida?
      Usa los escenarios para ver c√≥mo se logra un camino o un ciclo euleriano.
    </div>
    <div class="controls" role="toolbar" aria-label="Controles">
      <button id="btn-euler" class="primary">üîç Analizar Grados</button>
      <button id="btn-camino" class="primary">üõ§Ô∏è Crear Camino Euleriano</button>
      <button id="btn-ciclo" class="primary">üîÑ Crear Ciclo Euleriano</button>
      <button id="btn-reset" class="warn">‚ôªÔ∏è Reiniciar Grafo Original</button>
      <button id="btn-theme" class="ghost">üåô Tema</button>
      <button id="btn-help" class="ghost">‚ùì Ayuda</button>
      <button id="btn-find-paths" class="success">üîç Encontrar Todos los Caminos</button>
      <button id="btn-explore-dfs" class="explore">üë®‚Äçüíª Explorar con DFS</button>
    </div>
  </div>
</header>

<main class="main">
  <div class="explanation">
    <strong>¬øPor qu√© es imposible?</strong> El teorema de Euler establece que un grafo tiene un camino euleriano si y solo si tiene 0 o 2 v√©rtices de grado impar.
    En K√∂nigsberg, todos los v√©rtices (A:5, B:3, C:3, D:3) tienen grado impar, por lo que es imposible encontrar tal recorrido.
  </div>

  <div class="panel">
    <div class="stats">
      <div class="stat"><b>üìç Posici√≥n:</b> <span id="pos" class="mono">‚Äî</span></div>
      <div class="stat"><b>üåâ Puentes usados:</b> <span id="count" class="mono">0</span> / <span id="total" class="mono">7</span></div>
      <div class="stat"><b>üõ§Ô∏è Ruta:</b> <span id="path" class="mono">‚Äî</span></div>
      <div class="stat"><b>üìä Grados (A,B,C,D):</b> <span id="deg" class="mono">5, 3, 3, 3</span></div>
    </div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress" style="width:0%"></div>
    </div>
  </div>

  <div id="board" class="board">
    <svg viewBox="0 0 800 520" aria-label="Grafo equivalente a los puentes de K√∂nigsberg" style="aspect-ratio: 16/9">
      <g id="edges"></g>
      <g id="nodes">
        <circle class="node" id="node-C" cx="120" cy="90" r="9" tabindex="0" />
        <text class="label big" x="120" y="70" text-anchor="middle">C</text>
        <circle class="node" id="node-A" cx="120" cy="260" r="9" tabindex="0" />
        <text class="label big" x="120" y="240" text-anchor="middle">A</text>
        <circle class="node" id="node-B" cx="120" cy="430" r="9" tabindex="0" />
        <text class="label big" x="120" y="450" text-anchor="middle">B</text>
        <circle class="node" id="node-D" cx="680" cy="260" r="9" tabindex="0" />
        <text class="label big" x="680" y="240" text-anchor="middle">D</text>
      </g>
      <circle id="walker-graph" r="7" cx="120" cy="260" style="display:none"/>
    </svg>
  </div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<!-- Modal de Ayuda -->
<div id="help-modal" class="modal-overlay" style="display:none">
  <div class="modal-content">
    <h3>üéì Gu√≠a de Uso - Puentes de K√∂nigsberg</h3>
    <div class="help-sections">
        <h4>üìñ El Problema</h4>
        <p>En 1736, Leonhard Euler resolvi√≥ si era posible cruzar cada uno de los 7 puentes de K√∂nigsberg exactamente una vez y regresar al punto de partida.</p>
        <h4>üéØ C√≥mo Jugar</h4>
        <p>Haz clic en un v√©rtice (A, B, C, D) para comenzar, luego en un puente disponible (resaltado en verde) para cruzarlo. Intenta cruzar todos los puentes sin repetir.</p>
        <h4>üî¨ Teorema de Euler</h4>
        <p>Un grafo tiene un camino euleriano si y solo si tiene 0 o 2 v√©rtices de grado impar. En K√∂nigsberg, todos los v√©rtices son impares (A:5, B:3, C:3, D:3), por lo que es imposible.</p>
        <h4>üë®‚Äçüíª Explorador DFS</h4>
        <p>Usa el explorador para visualizar c√≥mo el algoritmo de B√∫squeda en Profundidad (DFS) con backtracking intenta encontrar una soluci√≥n, construyendo un √°rbol de decisiones en tiempo real.</p>
    </div>
    <button id="close-help" class="primary">Entendido</button>
  </div>
</div>

<!-- Modal de Caminos Eulerianos -->
<div id="paths-modal" class="modal-overlay" style="display:none">
  <div class="modal-content paths-modal">
    <h3>üõ§Ô∏è Todos los Caminos Eulerianos Posibles</h3>
    <div class="paths-info"><p id="paths-summary">Analizando el grafo...</p></div>
    <div class="paths-container"><div id="paths-list" class="paths-list"></div></div>
    <div class="paths-actions">
      <button id="btn-animate-path" class="primary">‚ñ∂Ô∏è Animar Camino</button>
      <button id="btn-copy-path" class="ghost">üìã Copiar</button>
      <button id="close-paths" class="warn">Cerrar</button>
    </div>
  </div>
</div>

<!-- Modal Explorador DFS -->
<div id="dfs-modal" class="modal-overlay" style="display:none">
  <div class="modal-content dfs-modal">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
      <h3>üë®‚Äçüíª Explorador DFS con Backtracking</h3>
      <div class="controls">
          <button id="dfs-play" class="primary">‚ñ∂Ô∏è Play</button>
          <button id="dfs-step" class="ghost"> Avanzar</button>
          <select id="dfs-speed" class="ghost" style="padding: 8px;">
              <option value="800">Lento</option>
              <option value="300" selected>Normal</option>
              <option value="50">R√°pido</option>
          </select>
          <button id="dfs-export" class="ghost">üíæ Exportar</button>
          <button id="dfs-reset" class="ghost">‚ôªÔ∏è Reiniciar</button>
          <button id="close-dfs" class="warn">Cerrar</button>
      </div>
    </div>
    <div class="dfs-explorer-layout">
      <div class="dfs-explorer-content">
        <div class="dfs-main-panel dfs-panel">
          <h4>üå≥ √Årbol de Exploraci√≥n (<span id="dfs-search-type"></span>)</h4>
          <div id="dfs-tree-container"></div>
        </div>
        <div class="dfs-side-panel">
          <div class="dfs-panel">
            <h4>üìä Estad√≠sticas</h4>
            <div class="dfs-stats-grid">
              <span>Pasos:</span> <b id="dfs-steps">0</b>
              <span>Backtracks:</span> <b id="dfs-backtracks">0</b>
              <span>Soluciones:</span> <b id="dfs-solutions">0</b>
              <span>Profundidad Max:</span> <b id="dfs-max-depth">0</b>
            </div>
          </div>
          <div class="dfs-panel" style="min-height: 0;">
            <h4>üìö Stack y Log</h4>
            <div id="dfs-stack" class="dfs-stack" style="margin-bottom: 8px;"></div>
            <div id="dfs-log" class="dfs-log-container"></div>
          </div>
        </div>
      </div>
      <div id="dfs-timeline" class="dfs-timeline"></div>
    </div>
  </div>
</div>

<footer><hr><div>Material elaborado por el profesor Sergio Gevatschnaider</div></footer>

<script>
/* ===== Datos del grafo ===== */
const G_LAYOUT = {A:{x:120,y:260}, B:{x:120,y:430}, C:{x:120,y:90}, D:{x:680,y:260}};
const BASE_EDGES = [ {id:"AC1", u:"A", v:"C", n:2, k:0}, {id:"AC2", u:"A", v:"C", n:2, k:1}, {id:"AB1", u:"A", v:"B", n:2, k:0}, {id:"AB2", u:"A", v:"B", n:2, k:1}, {id:"AD",  u:"A", v:"D", n:1, k:0}, {id:"CD",  u:"C", v:"D", n:1, k:0}, {id:"BD",  u:"B", v:"D", n:1, k:0} ];
let current = null, used = new Set(), seq = [], edges = structuredClone(BASE_EDGES);
let allPaths = [], selectedPathIndex = 0;

/* ===== Referencias UI ===== */
const $edges = document.getElementById("edges"), $pos = document.getElementById("pos"), $count = document.getElementById("count"), $total = document.getElementById("total"), $path = document.getElementById("path"), $deg = document.getElementById("deg"), $toast = document.getElementById("toast"), walkerG = document.getElementById("walker-graph");

/* ===== Utilidades y Renderizado ===== */
function toast(msg, ms=3500) { $toast.textContent = msg; $toast.classList.add("show"); clearTimeout(window._tt); window._tt = setTimeout(() => $toast.classList.remove('show'), ms); }
function setPos(v) { current = v; $pos.textContent = v || "‚Äî"; if (v && seq.length === 0) seq.push(v); updateUI(); updateNodeStates(); }
function otherEnd(e, at) { return e.u === at ? e.v : e.u; }
function degs() { const d = Object.fromEntries(Object.keys(G_LAYOUT).map(k=>[k,0])); edges.forEach(e => { d[e.u]++; d[e.v]++; }); return d; }
function eulerMsg() { const d = degs(); const odd = Object.keys(d).filter(k => d[k] % 2 === 1); return { d, odd, text: odd.length === 0 ? "üéâ ¬°Ciclo Euleriano posible!" : odd.length === 2 ? `‚úÖ Camino Euleriano posible entre ${odd.join(" y ")}!` : `‚ùå ${odd.length} impares: Recorrido imposible.` }; }
function updateNodeStates() { Object.keys(G_LAYOUT).forEach(node => { const el = document.getElementById(`node-${node}`); if (el) el.classList.toggle('active', node === current); }); }
function pathFor(u, v, k, n) { const p = G_LAYOUT[u], q = G_LAYOUT[v], dx = q.x-p.x, dy = q.y-p.y, len = Math.hypot(dx,dy)||1, nx=dx/len, ny=dy/len, px=-ny, py=nx, offset=(n===1)?0:(k%2===0)?38:-38, c1x=p.x+dx*0.25+px*offset, c1y=p.y+dy*0.25+py*offset, c2x=p.x+dx*0.75+px*offset, c2y=p.y+dy*0.75+py*offset; return `M ${p.x} ${p.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${q.x} ${q.y}`; }
function renderEdges() { $edges.innerHTML = ""; edges.forEach(e => { const p = document.createElementNS("http://www.w3.org/2000/svg", "path"); p.setAttribute("d", pathFor(e.u, e.v, e.k, e.n)); p.id = e.id; p.classList.add("edge"); p.addEventListener("click", () => tryCross(e)); $edges.appendChild(p); }); $total.textContent = String(edges.length); }
function updateUI() { edges.forEach(e => { const el = document.getElementById(e.id); if (!el) return; el.classList.toggle('used', used.has(e.id)); el.classList.toggle('available', !!(current && !used.has(e.id) && (e.u === current || e.v === current))); }); const info = eulerMsg(); const degreesDisplay = Object.entries(info.d).map(([v, d]) => `${v}:${d}${d%2===0?'(par)':'(impar)'}`).join(', '); $deg.textContent = `${degreesDisplay} ‚Äî ${info.text}`; document.getElementById("progress").style.width = `${edges.length > 0 ? (used.size / edges.length) * 100 : 0}%`; }

/* ===== L√≥gica del Juego y Grafo ===== */
function reset() { setGraphState(structuredClone(BASE_EDGES)); }
function clearCurrentPath() { used.clear(); seq = []; current = null; $pos.textContent = "‚Äî"; $count.textContent = "0"; $path.textContent = "‚Äî"; document.getElementById("progress").style.width = "0%"; walkerG.style.display = "none"; updateNodeStates(); updateUI(); }

function setGraphState(newEdges) {
    edges = newEdges;
    lastGraphSignature = getGraphSignature();

    if (document.getElementById('dfs-modal').style.display === 'flex') {
        generateDfsTranscript();
        recomputeStatsFromTranscript();
        resetDfsExplorer();
    }

    clearCurrentPath();
    renderEdges();
    updateUI();
}
document.getElementById("btn-camino").addEventListener("click", () => { setGraphState(structuredClone(BASE_EDGES).filter(e => e.id !== "AD")); toast(`üõ§Ô∏è Grafo modificado para Camino Euleriano.`, 4000); });
document.getElementById("btn-ciclo").addEventListener("click", () => { const newEdges = [ ...structuredClone(BASE_EDGES).map(e => e.id === "AD" ? { ...e, n: 2 } : e), {id:"AD-extra", u:"A", v:"D", n:2, k:1}, {id:"BC-extra", u:"B", v:"C", n:1, k:0} ]; setGraphState(newEdges); toast(`üîÑ Grafo modificado para Ciclo Euleriano.`, 4000); });
Object.keys(G_LAYOUT).forEach(v => { document.getElementById(`node-${v}`)?.addEventListener("click", () => { if (used.size > 0 && current) { toast("Ruta en curso. Reinicia para cambiar."); return; } setPos(v); toast(`üö∂ Inicio en ${v}.`); }); });
function tryCross(e) { if (!e || used.has(e.id) || !current || (e.u !== current && e.v !== current)) return; const next = otherEnd(e, current); animateAlong(e, () => { used.add(e.id); if (seq.length === 0) seq.push(current); seq.push(next); setPos(next); $count.textContent = String(used.size); $path.textContent = seq.join(' ‚Üí '); if (used.size === edges.length) toast("üéâ ¬°Recorrido completo!", 4000); else if (edges.filter(ed => !used.has(ed.id) && (ed.u === next || ed.v === next)).length === 0) toast(`üö´ Atrapado en ${next}.`); }); }
function animateAlong(stepOrEdge, done, reverse = false) { const edgeId = stepOrEdge.id || stepOrEdge.edgeId; const path = document.getElementById(edgeId); if (!path) { done && done(); return; } const len = path.getTotalLength(), start = performance.now(), duration = 300; walkerG.style.display = ""; requestAnimationFrame(function step(t) { let k = Math.min(1, (t - start) / duration); if (reverse) k = 1 - k; const pt = path.getPointAtLength(k * len); walkerG.setAttribute('cx', pt.x); walkerG.setAttribute('cy', pt.y); if ((!reverse && k < 1) || (reverse && k > 0)) { requestAnimationFrame(step); } else { done && done(); } }); }

/* ===== Eventos Generales ===== */
document.getElementById("btn-reset").addEventListener("click", () => { reset(); toast("üîÑ Grafo original restaurado."); });
document.getElementById("btn-euler").addEventListener("click", () => toast(eulerMsg().text, 4000));
document.getElementById("btn-theme").addEventListener("click", () => { const newTheme = document.documentElement.dataset.theme === 'dark' ? 'light' : 'dark'; document.documentElement.dataset.theme = newTheme; localStorage.setItem('theme', newTheme); document.getElementById("btn-theme").textContent = newTheme === 'dark' ? '‚òÄÔ∏è Tema' : 'üåô Tema'; });
document.getElementById("btn-help").addEventListener("click", () => document.getElementById("help-modal").style.display = "flex");
document.getElementById("close-help").addEventListener("click", () => document.getElementById("help-modal").style.display = "none");
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') ['help-modal', 'paths-modal', 'dfs-modal'].forEach(id => document.getElementById(id).style.display = 'none'); });

/* ===== B√∫squeda de Caminos (Modal Principal) ===== */
function removeDuplicateVertexSequences(paths) { const uniquePaths = [], seen = new Set(); for (const path of paths) { const key = path.join('‚Üí'); if (!seen.has(key)) { seen.add(key); uniquePaths.push(path); } } return uniquePaths; }
function findAllEulerianPaths() { const { odd } = eulerMsg(); if (odd.length > 2) return { possible: false, paths: [] }; if (odd.length === 0) return findEulerianCycles(); return findEulerianPaths(odd[0], odd[1]); }
function findEulerianPaths(start, end) { const paths = [], adj = buildAdjacencyList(); function dfs(c,p,u) { if(u.size===edges.length){if(c===end)paths.push([...p]);return;}(adj[c]||[]).forEach(e=>{if(!u.has(e.id)){u.add(e.id);p.push(otherEnd(e,c));dfs(otherEnd(e,c),p,u);p.pop();u.delete(e.id);}}); } dfs(start,[start],new Set()); const unique = removeDuplicateVertexSequences(paths); return { possible:true, paths:unique, message:`‚úÖ Encontrados ${unique.length} caminos √∫nicos de ${start} a ${end}`}; }
function findEulerianCycles() { const paths = [], adj = buildAdjacencyList(), start = Object.keys(G_LAYOUT)[0]; function dfs(c,p,u) { if(u.size===edges.length){if(c===start)paths.push([...p]);return;}(adj[c]||[]).forEach(e=>{if(!u.has(e.id)){u.add(e.id);p.push(otherEnd(e,c));dfs(otherEnd(e,c),p,u);p.pop();u.delete(e.id);}}); } dfs(start,[start],new Set()); const unique = removeDuplicateVertexSequences(removeDuplicateCycles(paths)); return { possible:true, paths:unique, message:`üîÑ Encontrados ${unique.length} ciclos √∫nicos`}; }
function buildAdjacencyList() { const adj = {}; edges.forEach(e => { (adj[e.u] = adj[e.u] || []).push(e); (adj[e.v] = adj[e.v] || []).push(e); }); return adj; }
function removeDuplicateCycles(paths) { const u=[],s=new Set();for(const p of paths){if(p.length<2||p[0]!==p[p.length-1])continue;const c=p.slice(0,-1),m=c.reduce((a,b)=>a<b?a:b),i=c.indexOf(m),n=[...c.slice(i),...c.slice(0,i)],r=[n[0],...n.slice(1).reverse()],k1=n.join('‚Üí'),k2=r.join('‚Üí');if(!s.has(k1)&&!s.has(k2)){s.add(k1);s.add(k2);u.push(p);}}return u; }
document.getElementById("btn-find-paths").addEventListener("click", showAllPaths);
document.getElementById("close-paths").addEventListener("click", () => document.getElementById("paths-modal").style.display = "none");
document.getElementById("btn-animate-path").addEventListener("click", () => { document.getElementById("paths-modal").style.display = "none"; animateSelectedPath(); });
function showAllPaths() { const result = findAllEulerianPaths(); allPaths = result.paths; selectedPathIndex = 0; document.getElementById('paths-summary').textContent = result.message; const list = document.getElementById('paths-list'); list.innerHTML = ''; if (allPaths.length > 0) { allPaths.forEach((path, i) => { const item = document.createElement('div'); item.className = 'path-item'; item.onclick = () => selectPath(i); const isCycle = path[0] === path[path.length - 1]; item.innerHTML = `<div class="path-number">${isCycle?'Ciclo':'Camino'} ${i + 1}</div><div class="path-sequence">${path.join(' ‚Üí ')}</div>`; list.appendChild(item); }); selectPath(0); } else { list.innerHTML = '<p style="text-align:center;padding:20px;">No se encontraron caminos</p>'; } document.getElementById('paths-modal').style.display = 'flex'; }
function selectPath(index) { selectedPathIndex = index; document.querySelectorAll('.path-item').forEach((item, i) => item.classList.toggle('selected', i === index)); }
function animateSelectedPath() { if (allPaths.length === 0) return; const path = allPaths[selectedPathIndex]; clearCurrentPath(); let step = 0; function animateStep() { if (step >= path.length - 1) { toast(`üéâ ¬°Recorrido completado!`, 3000); return; } const u = path[step], v = path[step + 1]; const edge = edges.find(e => !used.has(e.id) && ((e.u===u&&e.v===v)||(e.u===v&&e.v===u))); if (edge) { setPos(u); setTimeout(() => { tryCross(edge); step++; setTimeout(animateStep, 800); }, 300); } else { step++; animateStep(); } } animateStep(); }

/* ===== Explorador DFS ===== */
const dfsPlayer = { transcript: [], currentIndex: -1, interval: null, speed: 300, isPlaying: false, stats: { steps: 0, backtracks: 0, solutions: 0, maxDepth: 0 }};
let lastGraphSignature = '';

function getGraphSignature() {
    return edges.map(e => `${e.u}-${e.v}-${e.id}`).sort().join('|');
}

// CORRECCI√ìN FINAL: generateDfsTranscript con la condici√≥n de soluci√≥n estricta
function generateDfsTranscript() {
    const transcript = [], adj = buildAdjacencyList(), { odd } = eulerMsg();
    const startNode = (odd.length === 2) ? odd[0] : Object.keys(G_LAYOUT)[0];
    const endNode = (odd.length === 2) ? odd[1] : startNode;
    
    const isCycle = (odd.length === 0);
    const searchType = isCycle ? 'Ciclo Euleriano' : (odd.length === 2 ? 'Camino Euleriano' : 'B√∫squeda Inv√°lida');
    document.getElementById('dfs-search-type').textContent = searchType;

    function dfs(curr, path, usedEdges) {
        // Condici√≥n de √©xito: SOLO cuando se han usado TODAS las aristas
        if (usedEdges.size === edges.length) {
            if (isCycle) {
                // Para ciclos: debe regresar al punto de inicio
                if (curr === startNode) {
                    transcript.push({ type: 'solution', path: [...path] });
                }
            } else {
                // Para caminos: debe llegar al nodo final espec√≠fico
                if (curr === endNode) {
                    transcript.push({ type: 'solution', path: [...path] });
                }
            }
            return; // IMPORTANTE: salir inmediatamente despu√©s de evaluar
        }
        
        const availableEdges = (adj[curr] || []).filter(e => !usedEdges.has(e.id));
        if (availableEdges.length === 0 && usedEdges.size < edges.length) {
             transcript.push({ type: 'dead_end', from: curr, path: [...path] });
        }
        
        for (const edge of availableEdges) {
            const next = otherEnd(edge, curr);
            transcript.push({ type: 'push', from: curr, to: next, edgeId: edge.id, path: [...path, next] });
            usedEdges.add(edge.id);
            path.push(next);
            dfs(next, path, usedEdges);
            path.pop();
            usedEdges.delete(edge.id);
            transcript.push({ type: 'pop', from: next, to: curr, edgeId: edge.id, path: [...path] });
        }
    }
    
    transcript.push({ type: 'start', node: startNode, path: [startNode] });
    if (odd.length === 0 || odd.length === 2) {
        dfs(startNode, [startNode], new Set());
    }
    dfsPlayer.transcript = transcript;
    dfsPlayer.currentIndex = -1;
}

function recomputeStatsFromTranscript() {
    const s = { steps: 0, backtracks: 0, solutions: 0, maxDepth: 0 };
    for (const ev of dfsPlayer.transcript) {
        if (ev.type === 'push') s.steps++;
        if (ev.type === 'pop') s.backtracks++;
        if (ev.type === 'solution') s.solutions++;
        if (ev.path) s.maxDepth = Math.max(s.maxDepth, ev.path.length);
    }
    dfsPlayer.stats = s;
}

function renderDfsStep() {
    if (dfsPlayer.currentIndex < 0 || dfsPlayer.currentIndex >= dfsPlayer.transcript.length) {
        if (dfsPlayer.isPlaying) toggleDfsPlay();
        return;
    }
    const step = dfsPlayer.transcript[dfsPlayer.currentIndex];
    
    const statsUpToNow = { steps: 0, backtracks: 0, solutions: 0, maxDepth: 0 };
    for (let i = 0; i <= dfsPlayer.currentIndex; i++) {
        const event = dfsPlayer.transcript[i];
        if (event.type === 'push') statsUpToNow.steps++;
        if (event.type === 'pop') statsUpToNow.backtracks++;
        if (event.type === 'solution') statsUpToNow.solutions++;
        if (event.path) statsUpToNow.maxDepth = Math.max(statsUpToNow.maxDepth, event.path.length);
    }
    document.getElementById('dfs-steps').textContent = statsUpToNow.steps;
    document.getElementById('dfs-backtracks').textContent = statsUpToNow.backtracks;
    document.getElementById('dfs-solutions').textContent = statsUpToNow.solutions;
    document.getElementById('dfs-max-depth').textContent = statsUpToNow.maxDepth;

    const logContainer = document.getElementById('dfs-log');
    const logEntry = document.createElement('div');
    logEntry.classList.add('dfs-log-entry');
    document.querySelectorAll('.edge.dfs-explore, .edge.dfs-backtrack').forEach(el => el.classList.remove('dfs-explore', 'dfs-backtrack'));

    switch (step.type) {
        case 'start':
            logEntry.textContent = `‚ñ∂Ô∏è Iniciando desde ${step.node}`;
            break;
        case 'push':
            logEntry.classList.add('push');
            logEntry.textContent = `üü¢ ${step.from} ‚Üí ${step.to}`;
            document.getElementById(step.edgeId)?.classList.add('dfs-explore');
            animateAlong(step, null, false);
            break;
        case 'pop':
            logEntry.classList.add('pop');
            logEntry.textContent = `üîô Backtrack ${step.from} ‚Üí ${step.to}`;
            document.getElementById(step.edgeId)?.classList.add('dfs-backtrack');
            animateAlong(step, null, true);
            break;
        case 'solution':
            logEntry.classList.add('solution');
            logEntry.textContent = `üèÜ ¬°Soluci√≥n encontrada!`;
            break;
        case 'dead_end':
            logEntry.classList.add('pop');
            logEntry.textContent = `üö´ Callej√≥n sin salida en ${step.from}`;
            break;
    }

    const stackElement = document.getElementById('dfs-stack');
    if (stackElement) {
        stackElement.innerHTML = (step.path || []).map(node => `<span class="dfs-stack-item">${node}</span>`).join('');
    }

    if (logContainer && logEntry.textContent) {
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
    }

    renderDfsTree();
}

function renderDfsTree() {
    const container = document.getElementById('dfs-tree-container');
    if (!container) return;
    
    let { width, height } = container.getBoundingClientRect();
    if (width <= 1 || height <= 1) { width = 600; height = 400; }

    const tree = { nodes: {}, links: new Set() };
    const transcriptSlice = dfsPlayer.transcript.slice(0, dfsPlayer.currentIndex + 1);
    
    if (transcriptSlice.length === 0) {
        container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--muted); font-style: italic;">Haz clic en "Avanzar" para comenzar la exploraci√≥n</div>';
        return;
    }

    transcriptSlice.forEach(step => {
        if ((step.type === 'push' || step.type === 'start') && step.path) {
            const pathKey = step.path.join('-');
            if (!tree.nodes[pathKey]) {
                const depth = step.path.length - 1;
                tree.nodes[pathKey] = { id: pathKey, label: step.path[step.path.length-1], depth: depth, status: 'explored' };
                if (step.path.length > 1) {
                    const parentKey = step.path.slice(0,-1).join('-');
                    tree.links.add({ source: parentKey, target: pathKey, status: 'explored' });
                }
            }
        }
    });

    const solutions = new Set(dfsPlayer.transcript.filter(s => s.type === 'solution').map(s => s.path.join('-')));
    const deadEnds = new Set(dfsPlayer.transcript.filter(s => s.type === 'dead_end').map(s => s.path.join('-')));
    const currentPath = dfsPlayer.transcript[dfsPlayer.currentIndex]?.path;
    const currentPathKey = currentPath ? currentPath.join('-') : '';

    Object.values(tree.nodes).forEach(node => {
        if (solutions.has(node.id)) node.status = 'solution';
        else if (deadEnds.has(node.id)) node.status = 'dead-end';
        if (currentPathKey.startsWith(node.id)) node.status = 'active';
    });
    
    tree.links.forEach(link => {
        const sourceNode = tree.nodes[link.source];
        const targetNode = tree.nodes[link.target];
        if (sourceNode && targetNode) {
            if (sourceNode.status === 'solution' && targetNode.status === 'solution') link.status = 'solution';
            else if (sourceNode.status === 'active' && targetNode.status === 'active') link.status = 'active';
            else if (targetNode.status === 'dead-end') link.status = 'dead-end';
        }
    });

    const maxDepth = Math.max(0, ...Object.values(tree.nodes).map(n => n.depth));
    const yPadding = 20, xPadding = 30;
    const yStep = (height - yPadding * 2) / Math.max(1, maxDepth);
    Object.values(tree.nodes).forEach(node => { node.y = yPadding + node.depth * yStep; });
    for (let d = 0; d <= maxDepth; d++) {
        const nodesAtDepth = Object.values(tree.nodes).filter(n => n.depth === d);
        const xStep = (width - xPadding * 2) / Math.max(1, nodesAtDepth.length);
        nodesAtDepth.forEach((node, i) => { node.x = xPadding + (i + 0.5) * xStep; });
    }

    let svgContent = `<svg id="dfs-tree-svg" viewBox="0 0 ${width} ${height}">`;
    svgContent += Array.from(tree.links).map(link => {
        const source = tree.nodes[link.source], target = tree.nodes[link.target];
        if (!source || !target) return '';
        return `<line class="tree-link ${link.status}" x1="${source.x}" y1="${source.y}" x2="${target.x}" y2="${target.y}"></line>`
    }).join('');
    svgContent += Object.values(tree.nodes).map(node => `<g><circle class="tree-node ${node.status}" cx="${node.x}" cy="${node.y}" r="8"></circle><text class="tree-label" x="${node.x}" y="${node.y}" dy="3">${node.label}</text></g>`).join('');
    svgContent += `</svg>`;
    container.innerHTML = svgContent;
}

function stepDfs() { if (dfsPlayer.currentIndex < dfsPlayer.transcript.length - 1) { dfsPlayer.currentIndex++; renderDfsStep(); } else if (dfsPlayer.isPlaying) { toggleDfsPlay(); } }
function toggleDfsPlay() { const btn = document.getElementById('dfs-play'); dfsPlayer.isPlaying = !dfsPlayer.isPlaying; btn.textContent = dfsPlayer.isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play'; if (dfsPlayer.isPlaying) dfsPlayer.interval = setInterval(stepDfs, dfsPlayer.speed); else clearInterval(dfsPlayer.interval); }
function resetDfsExplorer() {
    clearCurrentPath();
    if (dfsPlayer.isPlaying) toggleDfsPlay();
    dfsPlayer.currentIndex = -1;
    ['dfs-log', 'dfs-stack', 'dfs-timeline', 'dfs-tree-container'].forEach(id => document.getElementById(id).innerHTML = '');
    Object.keys(G_LAYOUT).forEach(nodeId => document.getElementById(`node-${nodeId}`).className = 'node');

    document.getElementById('dfs-steps').textContent = dfsPlayer.stats.steps;
    document.getElementById('dfs-backtracks').textContent = dfsPlayer.stats.backtracks;
    document.getElementById('dfs-solutions').textContent = dfsPlayer.stats.solutions;
    document.getElementById('dfs-max-depth').textContent = dfsPlayer.stats.maxDepth;
    
    renderDfsStep();
}
function exportDfsTranscript() { const data = { transcript: dfsPlayer.transcript, stats: dfsPlayer.stats }; const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `dfs-transcript.json`; a.click(); URL.revokeObjectURL(a.href); toast('üíæ Transcripci√≥n exportada.', 2000); }

document.getElementById('btn-explore-dfs').addEventListener('click', () => {
    const currentSignature = getGraphSignature();
    if (currentSignature !== lastGraphSignature || dfsPlayer.transcript.length === 0) {
        generateDfsTranscript();
        recomputeStatsFromTranscript();
        lastGraphSignature = currentSignature;
    }
    resetDfsExplorer();
    document.getElementById('dfs-modal').style.display = 'flex';
    setTimeout(() => renderDfsTree(), 100);
});

document.getElementById('close-dfs').addEventListener('click', () => {
    if (dfsPlayer.isPlaying) toggleDfsPlay();
    document.getElementById('dfs-modal').style.display = 'none';
    clearCurrentPath();
    document.querySelectorAll('.edge.dfs-explore, .edge.dfs-backtrack').forEach(el => el.classList.remove('dfs-explore', 'dfs-backtrack'));
    Object.keys(G_LAYOUT).forEach(nodeId => document.getElementById(`node-${nodeId}`).className = 'node');
});
document.getElementById('dfs-play').addEventListener('click', toggleDfsPlay);
document.getElementById('dfs-step').addEventListener('click', stepDfs);
document.getElementById('dfs-reset').addEventListener('click', () => {
    generateDfsTranscript();
    recomputeStatsFromTranscript();
    resetDfsExplorer();
});
document.getElementById('dfs-export').addEventListener('click', exportDfsTranscript);
document.getElementById('dfs-speed').addEventListener('change', (e) => { dfsPlayer.speed = parseInt(e.target.value, 10); if (dfsPlayer.isPlaying) { toggleDfsPlay(); toggleDfsPlay(); } });

/* ===== Inicializaci√≥n ===== */
(function init() { const theme = localStorage.getItem('theme') || 'light'; document.documentElement.dataset.theme = theme; document.getElementById("btn-theme").textContent = theme === 'dark' ? '‚òÄÔ∏è Tema' : 'üåô Tema'; reset(); })();
</script>
</body>
</html>